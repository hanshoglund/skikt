; load "~/Documents/Musik/Skikt/Skikt.vitry"

; =============================================================================
; Skikt
; Hans Hoglund (2011)
; Vitry v0.1.2
; =============================================================================

module Hans.Music.Skikt

scoreEditor = "/Applications/Sibelius 6.app"
fileDir     = "/Users/hans/Documents/Musik/Skikt/output/"
fileName    = "out"
preview     = false
fixClefs    = false

info   = [ ("title",  "Skikt")
         , ("author", "Hans Hoglund 2011") ]

insts  = [ ("perc1", "percussion",  [ "snare-drum"
                                    , "bass-drum"
                                    , "crash-cymbal"
                                    , "splash-cymbal" ]) ]
                                  
fl     = ("fl",   "flute",          [ ("abbr", "Fl.") ])
ob     = ("ob",   "oboe",           [ ("abbr", "Ob.") ])
cl     = ("cl",   "bflat-clarinet", [ ("abbr", "Kl.") ])
bsn    = ("bsn",  "bassoon",        [ ("abbr", "Fag.") ])
hrn    = ("hrn",  "horn",           [ ("abbr", "Hrn.") ])
tpt    = ("tpt",  "bflat-trumpet",  [ ("abbr", "Tpt.") ])
tbn    = ("tbn",  "tenor-trombone", [ ("abbr", "Tbn.") ])
pno    = ("pno",  "piano",          [ ("abbr", "Pno.") ])
vib    = ("vib",  "vibraphone",     [ ("abbr", "Vib.") ])
crot   = ("crot", "vibraphone",     [ ("abbr", "Crot.")
                                  , ("name", "Crotales") ])
prc    = ("perc", "perc1",          [ ("abbr", "Perc.")
                                  , ("name", "Percussion") ])
vl1    = ("vl1",  "violin",         [ ("abbr", "Vl. I") ])
vl2    = ("vl2",  "violin",         [ ("abbr", "Vl. II") ])
vla    = ("vla",  "viola",          [ ("abbr", "Vla.") ])
vc     = ("vc",   "cello",          [ ("abbr", "Vc.")
                                  , ("name", "Violoncello") ])
db     = ("db",   "bass",           [ ("abbr", "Kb.") ])

parts  = [ fl, ob, cl, bsn
         , hrn, tpt, tbn
         , pno, vib, crot, prc
         , vl1, vl2, vla, vc, db ]
decls  = insts ++ parts

snareDrum = `snareDrum
bassDrum  = `bassDrum
smallCymbal = `smallCymbal 
largeCymbal = `largeCymbal

percNote inst = match inst
    x : bassDrum    = 65
    x : snareDrum   = 72
    x : smallCymbal = 76
    x : largeCymbal = 79





; events _ =
;     let durs    = map (+ 1) (rands 8)
;         pitches = map (+ 60) (rands 10)               
;         arts    = unroll (pluck pick [["."], ["-"]])
;         notes   = zip5 (loop (1/2)) pitches noise arts (loop [])
;         rests   = zip4 (loop "+") durs (loop []) (loop []) 
;         events  = map (setPart vl1) (melody (interl notes rests)) 
;              
    ; let durs    = map (+ 1) (rands 8)
    ;     pitches = map (+ 45) (rands 30)
    ;     notes   = zip5 (loop (1/2)) pitches (loop 0.5) (loop ["lv"]) (loop [])
    ;     rests   = zip4 (loop "+") durs (loop []) (loop []) 
    ;     events  = map (setPart pno) (melody (interl notes rests)) 

    
    ; let durs    = (loop (4 + 1/3))
    ;     pitches = (palindrome (60 .. 72)) 
    ;     dyns    = (cycle (map (approx . ((flip (/)) 4)) (0 .. 4))) 
    ;     notes   = zip5 durs pitches dyns (loop []) (loop [])
    ;     events = 
    ;         (map (setPart pno) . map (setMarks ["-"]) . melody)
    ;         notes   
        
        ; take 60 (cycle events)


events _ = 
    do  foo = take 3 (melody (loop 1) (cycle (60 .. 72))) 
        bar = take 3 (chords (loop 1) (map major (map (+ 60) (rands 10)))) 

        ; events = foo
        events = parallel foo bar
        ; events = sequence events events
        events = (map (setPart cl) events)
        events = (map (setVoice [1, 2, 3, 4]) events)
        events

major root = [root, root + 4, root + 7]






; Utils

noise = unfold (fn (x) (randomDouble (), 0)) 0

; Main program

printEvents _ = do force (map print (events ()))
                ()
main _ = (export . fomus) (events (), decls, info)
test _ = fomus (events (), decls, info)
dump _ = join "\n" (events ())
















; =============================================================================
; FOMUS

; module Music.Fomus

; Interface to the FOMUS notation engine by David Psenicka
; See http://fomus.sourceforge.net/

; The workflow is to create a data structure representing a score
; and pass it to the fomus function. This function generates a
; text on a format understood by Fomus, which may be written to
; a fomus text file.

time     = nil | prec | "+"
grace    = nil | prec | "+"
dur      = nil | prec | "+" | "-"
pitch    = nil | prec
dyn      = nil | double
voice    = nil | int  | [int]
fomusId  = str

markType = "(.." | "*" | "+" | "-" | "." | ".((." | ".(." | "..)" | "..))" | "..<"
         | "..>" | "." | "dash)" | "..dash))" | "..dot)" | "..dot))" | "..grace)"
         | "..ped" | "..tup" | "..x!" | "..x^" | "..x_" | ".<." | ".>." | ".dash((."
         | ".dash(." | ".dot((." | ".dot(." | ".grace(." | ".ped." | ".x!." | ".x^."
         | ".x_." | "/" | "/." | "0" | "<.." | ">" | ">.." | "^" | "arco" | "arp"
         | "arp^" | "arp_" | "artharm-base" | "artharm-sounding" | "artharm-touched"
         | "bellsup" | "break<" | "break>" | "breath" | "breath<" | "breath>"
         | "cuivre" | "damp" | "dash((.." | "dash(.." | "dot((.." | "dot(.."
         | "downbow" | "dyn" | "etouf" | "f" | "ferm" | "ferm-long" | "ferm-short"
         | "ferm-verylong" | "ff" | "fff" | "ffff" | "fffz" | "ffz" | "flaut" | "flt"
         | "fz" | "gliss<" | "gliss>" | "grace(.." | "leg" | "legno" | "longtr"
         | "longtr2" | "lv" | "mf" | "moltoleg" | "moltovib" | "mp" | "mute"
         | "natharm-sounding" | "natharm-string" | "natharm-touched" | "nonleg"
         | "nonvib" | "o" | "ord" | "p" | "ped.." | "pizz" | "pont" | "port<"
         | "port>" | "pp" | "ppp" | "pppp" | "ppppp" | "pppppp" | "punta" | "rf"
         | "rfz" | "ric" | "salt" | "sf" | "sff" | "sfff" | "sfffz" | "sffz" | "sfz"
         | "slap" | "snap" | "snappizz" | "spic" | "sul" | "table" | "tall" | "tasto"
         | "tempo" | "trem" | "trem2" | "tup.." | "unmute" | "upbow" | "vib" | "x"
         | "x!" | "x!.." | "x^" | "x^.." | "x_" | "x_.." | "~" | (`-) | (`.) | (`!) | (`+)

mark     = markType
         | (markType, (num | str))
         | (markType, (num | str), (num | str))

setting  = (str, (str | num | [str] | [num]))

clef     = [setting]
staff    = ([clef],  [setting])
template = fomusId
percInst = fomusId
         | (fomusId, [setting])
inst     = fomusId
         | (fomusId, template, [percInst], [staff], [setting])
         | (fomusId, template, [percInst])
partMap  = (voice, voice, fomusId)
metaPart = (fomusId, [partMap])
part     = nil
         | metaPart
         | (fomusId, inst, [setting]) 
note     = (part, voice, time, grace, dur, pitch, dyn, [mark], [setting])
         | (part, voice, time, dur, pitch, dyn, [mark], [setting])
         | (time, dur, pitch, dyn, [mark], [setting])
         | (dur, pitch, dyn, [mark], [setting])
         | (pitch, dyn, [mark], [setting])
rest     = (part, voice, time, grace, dur, [mark], [setting])
         | (time, dur, [mark], [setting])
meas     = (time, dur, [setting])
         | (dur, [setting])
        
decl     = part | inst | metaPart | percInst | staff | clef
event    = note | rest | meas

score    = ([event], [decl], [setting])


expandEvent e : event = match e       
    (r, v, t, g, d, p, n, m, s)  : note = e
    (r, v, t, d, p, n:dyn, m, s) : note = (r,  v,  t,  (), d,  p, n, m, s)
    (t, d, p, n:dyn, m, s)       : note = ((), (), t,  (), d,  p, n, m, s)
    (d, p, n:dyn, m, s)          : note = ((), (), (), (), d,  p, n, m, s)
    (p, n:dyn, m, s)             : note = ((), (), (), (), (), p, n, m, s)
    (p, v, t, g, d, m, s)        : rest = e
    (t, d, m, s)                 : rest = ((), (), t,  (), d,  m, s)
    (t, d, s)                    : meas = e
    (d, s)                       : meas = ((), d, s)

getNotePart    (r, _, _, _, _, _, _, _, _) = r
getNoteVoice   (_, v, _, _, _, _, _, _, _) = v
getNoteTime    (_, _, t, _, _, _, _, _, _) = t
getNoteGrace   (_, _, _, g, _, _, _, _, _) = g
getNoteDur     (_, _, _, _, d, _, _, _, _) = d
getNotePitch   (_, _, _, _, _, p, _, _, _) = p
getNoteDyn     (_, _, _, _, _, _, n, _, _) = n
getNoteMarks   (_, _, _, _, _, _, _, m, _) = m
getRestPart    (r, _, _, _, _, _, _)       = r
getRestVoice   (_, v, _, _, _, _, _)       = v
getRestTime    (_, _, t, _, _, _, _)       = t
getRestGrace   (_, _, _, g, _, _, _)       = g
getRestDur     (_, _, _, _, d, _, _)       = d
getRestMarks   (_, _, _, _, _, m, _)       = m
getMeasTime    (t, _, _)                   = t
getMeasDur     (_, d, _)                   = d
setNotePart  r (_, v, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteVoice v (r, _, t, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteTime  t (r, v, _, g, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteGrace g (r, v, t, _, d, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDur   d (r, v, t, g, _, p, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNotePitch p (r, v, t, g, d, _, n, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteDyn   n (r, v, t, g, d, p, _, m, s) = (r, v, t, g, d, p, n, m, s)
setNoteMarks m (r, v, t, g, d, p, n, _, s) = (r, v, t, g, d, p, n, m, s)
setRestPart  r (_, v, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestVoice v (r, _, t, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestTime  t (r, v, _, g, d, m, s)       = (r, v, t, g, d, m, s)
setRestGrace g (r, v, t, _, d, m, s)       = (r, v, t, g, d, m, s)
setRestDur   d (r, v, t, g, _, m, s)       = (r, v, t, g, d, m, s)
setRestMarks m (r, v, t, g, d, _, s)       = (r, v, t, g, d, m, s)
setMeasTime  t (_, d, s)                   = (t, d, s)
setMeasDur   d (t, _, s)                   = (t, d, s)

; event -> dur
getTime e = match e
    e : note = (getNoteTime . expandEvent) e
    e : rest = (getRestTime . expandEvent) e
    e : meas = (getMeasTime . expandEvent) e
getDur e = match e
    e : note = (getNoteDur . expandEvent) e
    e : rest = (getRestDur . expandEvent) e
    e : meas = (getMeasDur . expandEvent) e
getPart e = match e
    e : note = (getNotePart . expandEvent) e
    e : rest = (getRestPart . expandEvent) e
getVoice e = match e
    e : note = (getNoteVoice . expandEvent) e
    e : rest = (getRestVoice . expandEvent) e
getGrace e = match e
    e : note = (getNoteGrace . expandEvent) e
    e : rest = (getRestGrace . expandEvent) e
getMarks e = match e
    e : note = (getNoteMarks . expandEvent) e
    e : rest = (getRestMarks . expandEvent) e

; event -> prec |Â "+"
getActualDur x = if (getTime x == ()) 0 else (getDur x)

; note -> pitch
getPitch = getNotePitch . expandEvent
getDyn   = getNoteDyn   . expandEvent

; part | metaPart -> id
getName x = match x
    (id, _, _) : part  = id
    (id, _)    : metaPart = id

; a -> event -> event    
setTime   x e = match e
    e : note = setNoteTime  x (expandEvent e)
    e : rest = setRestTime  x (expandEvent e)
    e : meas = setMeasTime  x (expandEvent e)
setDur    x e = match e
    e : note = setNoteDur   x (expandEvent e)
    e : rest = setRestDur   x (expandEvent e)
    e : meas = setMeasDur   x (expandEvent e)
setPart   x e = match e
    e : note = setNotePart  x (expandEvent e)
    e : rest = setRestPart  x (expandEvent e)
setVoice  x e = match e
    e : note = setNoteVoice x (expandEvent e)
    e : rest = setRestVoice x (expandEvent e)
setGrace  x e = match e
    e : note = setNoteGrace x (expandEvent e)
    e : rest = setRestGrace x (expandEvent e)
setMarks  x e = match e
    e : note = setNoteMarks x (expandEvent e)
    e : rest = setRestMarks x (expandEvent e)
setPitch  x e = setNotePitch x (expandEvent e)
setDyn    x e = setNoteDyn   x (expandEvent e)

withTime  f x = setTime  (f (getTime  x)) x
withDur   f x = setDur   (f (getDur   x)) x
withPart  f x = setPart  (f (getPart  x)) x
withVoice f x = setVoice (f (getVoice x)) x
withGrace f x = setGrace (f (getGrace x)) x
withMarks f x = setMarks (f (getMarks x)) x
withPitch f x = setPitch (f (getPitch x)) x
withDyn   f x = setDyn   (f (getDyn   x)) x


; Time and duration is context-sensitive in Fomus. This means that we
; can get unexpected results when assembling events from various sources.

; To counter the problem we introduce normal-form event lists which are
; unaffected by surrounding events
;
; Normal form events lists take three shapes:
;   - Relative, where 
;       - durations are given explitly
;       - the first time value is a number 
;       - all other time values are "+" or nil
;   - Absolute, where 
;       - time values are given explitly
;       - the last duration is a number 
;       - and all other durations are "+" or nil
;   - Explicit, where 
;       - all time values and durations are given explitly

assureTimeAndDur t nt d nd event = 
    match (getTime event, getDur event)
        (_ : nt, _     ) = false
        (_,      _ : nd) = false
        (_ : t,  _ : d ) = true
        _                = false

; event -> bool
isRelativeEvent = assureTimeAndDur ("+" | ()) {}         _          ("+" | ())
isAbsoluteEvent = assureTimeAndDur _          ("+" | ()) ("+" | ()) {}
isExplicitEvent = assureTimeAndDur _          ("+" | ()) _          ("+" | ())

; [event] -> bool
isRelative xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (head xs) && (all isRelativeEvent) (tail xs)
isAbsolute xs = match xs
    _ : [] = true
    xs     = isExplicitEvent (last xs) && (all isAbsoluteEvent) (init xs)
isExplicit = all isExplicitEvent

isInNormalForm xs = isRelative xs || isAbsolute xs || isExplicit xs


; Basic event lists builders

; [time] -> [dur] -> [pitch] -> [note]
notes times durs pitches = zip6 times durs pitches (loop 0.5) (loop []) (loop [])

; [time] -> [dur] -> [note]
rests times durs         = zip4 times durs (loop []) (loop [])



; The melody, chord and chords functions generates homophonic music in relative form

; [dur] -> [pitch] -> [note]
melody durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = prepend (0, d, p, 0.5, [], []) (delay notes (loop "+") ds ps)

chordT time dur pitches = match pitches
    _ : []  = []
    (p, ps) = prepend (time, dur, p, 0.5, [], []) (delay notes (loop nil) (loop dur) ps)

chordsT time1 time2 durs pitches = match (durs, pitches)
    _ : [], _        = []
    _,      _ : []   = []
    (d, ds), (p, ps) = (delay chordT time1 d p ++ chordsT time2 time2 ds ps) 

; dur -> [pitch] -> [note]
chord = chordT 0

; [dur] -> [[pitch]] -> [note]
chords = chordsT 0 "+"


                                                                                                
; time -> [event] -> [event]
offset time = map (withTime (fn (x) match x (x : prec = x + time) (_ = x))) 

; [event] -> duration
duration xs = match xs
    _ : ()  = 0
    (x, xs) = let section = findIndex (matches prec) (map getTime xs)
                  offset  = getTime x + getActualDur x
                  if (section < 0)
                      offset + sum (map getActualDur xs)
                      offset + sum (map getActualDur (take section (prepend x xs)))
                      
; [event] -> [event]
sequence  xs ys = let dx = duration xs
                      dy = duration ys
                      prepend (0, dx + dy, [], []) xx ++ (offset dx ys)

parallel  xs ys = let dx = duration xs
                      dy = duration ys
                      prepend (0, dx + dy, [], []) xs ++ ys


; Simple inspectors for the repl
    
declType d = match d
    d : part     = `part
    d : inst     = `inst
    d : percInst = `percInst
    d : staff    = `staff
    d : clef     = `clef

eventType e = match e
    e : note     = `note
    e : rest     = `rest
    e : meas  = `meas


; Main export function
; Converts the given data structure to a text format understood by Fomus.
;    ( mark  |  decl  |  event  | setting | [mark] | [decl] | [event] | [setting] | score ) -> str

fomus data = match data
    (id, x, y)                : mark = "[" ++ string id ++ " " ++ fomus x ++ " " ++ fomus y ++ "]"
    (id, x)                   : mark = "[" ++ string id ++ " " ++ fomus x ++ "]"
    id                        : mark = "[" ++ string id ++ "]"
    
    (name, value)             : setting = name ++ "=" ++ fomus value
        
    (id, template, percInsts) : inst = "inst <"
                                    ++ "id="        ++ id              ++ " " 
                                    ++ "template="  ++ fomus template  ++ " " 
                                    ++ "percinsts=" ++ fomusList percInsts ++ ">"
    (id, inst, settings)      : part = "part <"
                                    ++ "id="   ++ id         ++ " " 
                                    ++ "inst=" ++ fomus inst ++ " " 
                                    ++ fomus settings        ++ ">"
    (id, partMaps)            : metaPart = "metapart <"
                                    ++ "id="    ++ string id          ++ " "
                                    ++ "parts=" ++ fomusList partMaps ++ ">"
    (from, to, id)            : partMap = "<"
                                    ++ "from-voice=" ++ string from ++ " "
                                    ++ "to-voice="   ++ string to   ++ " "
                                    ++ "part="       ++  string id  ++ ">"                                    
    
    (part, voice, time, grace, dur, pitch, dyn, marks, settings) : note = "note "
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ maybePitch pitch ++ " " 
                                    ++ maybeDynamic dyn ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (part, voice, time, grace, dur, marks, settings) : rest = "rest "
                                    ++ maybePart part   ++ " " 
                                    ++ maybeVoice voice ++ " " 
                                    ++ maybeTime time   ++ " " 
                                    ++ maybeGrace grace ++ " " 
                                    ++ maybeDur dur     ++ " " 
                                    ++ fomus marks      ++ " " 
                                    ++ fomus settings   ++ ";"
    (time, dur, settings)     : meas = ""
                                    ++ maybeTime time   ++ " "
                                    ++ maybeDur  dur    ++ " "
                                    ++ "meas <" ++ fomus settings ++ ">"
    event                     : event = (fomus . expandEvent) event

    (events, decls, settings) : score = join "\n\n" [fomus settings, fomus decls, fomus events]

    settings : [setting]    = join " " (map fomus settings)
    marks    : [mark]       = join " " (map fomus marks)
    event    : [event]      = join "\n" (map fomus event)
    decls    : [decl]       = join "\n" (map fomus decls)
    x        : str          = fomusStr x
    x        : num          = string x
    x        : ()           = ""
    xs       : [_]          = fomusList xs


fomusList xs = "(" ++ join " " (map fomus xs) ++ ")"
fomusStr x   = "\"" ++ x ++ "\""

maybePart x    = match x (x : () = "") (x = "part="    ++ getName x)
maybeVoice x   = match x (x : () = "") (x = "voice="   ++ listOrString x)
maybeTime x    = match x (x : () = "") (x = "time="    ++ string x)
maybeGrace x   = match x (x : () = "") (x = "grace="   ++ string x)
maybeDur x     = match x (x : () = "") (x = "dur="     ++ string x)
maybePitch x   = match x (x : () = "") (x = "pitch="   ++ string x)
maybeDynamic x = match x (x : () = "") (x = "dynamic=" ++ string x)
listOrString x = match x (x : [_] = fomusList x) (_ = string x)


; =============================================================================
; Output

fmsFile = fileDir ++ fileName ++ ".fms"
xmlFile = fileDir ++ fileName ++ ".xml"
lyFile  = fileDir ++ fileName ++ ".ly"


; Writes the given text to a file and displays it

export text = do
    writeFile fmsFile text
    if preview
        do run [ "fomus", fmsFile, "-o", lyFile ]
        ; else
        do run [ "fomus", fmsFile, "-o", xmlFile ]
            if fixClefs 
                do print "adjusting fomus clefs..."
                    replaceFile xmlFile
                        [ "<sign>F</sign>", "<sign>C</sign>" ]
                        [ "<sign>F</sign><line>4</line>", "<sign>C</sign><line>3</line>" ]
                ; else
                ()
            ; Open the score
            run [ "open", "-a", scoreEditor, xmlFile ]
